大道至简:zonefire框架

在线文档：http://hi.baidu.com/jvinkfzrcxgijqe/item/671fa4323782f7ed124b1452


编程序（任何一种语言），当项目规模大到一定程度（比如程序由多个模块构成，宿主程序有多个外挂的寄生程序）时，有两个问题会成为程序员的困扰：
1、各模块之间如何通信。程序是个整体，如何在一个模块中触发另外一个模块中的某些功能？如何把一个模块中的某些变化通知到其他模块而令其作出相应的反应？如何让主程序（宿主程序）和各运行时加载的swf子模块（寄生程序）之间进行无缝通信？

2、有点规模的程序总会有一些全局的数据（如来自xml的配置数据，后台服务数据）和管理器（如模块管理器、窗口管理器、服务管理器、缓存管理器、对象池、游戏任务管理器、战场管理器、教程管理器、错误管理器、日志管理器等）。这些数据和管理器你在任何地方都会可能调用，如何达到这个目的？现在比较常见的做法是用一个类的静态属性或静态方法来实现全局的访问。但这并不符合面向对象编程的理念，面向对象编程应该操作对象而不是类。

ZoneFire就是为了解决这些问题而生的。它把程序通过配置划分成若干区域（称为Zone即“事件区域”），任何一个区域（如A区域）的框架角色（称为Role，即参加框架互动的对象）可以向任何一个区域（如B区域）定向发送事件，而只要签入到B区域的框架角色就能侦听到该事件。这种机制的特点是对于任何一个框架角色来讲，事件的发送和侦听都是“门到门”的，即无论侦听者在程序的什么地方（比如是在一个运行时加载的SWF中甚至在此SWF再加载的子SWF中），事件发送者都能将事件直接发送给侦听者，而不像一些框架一样需要通过其他框架组件层层转发。但是由于区域是划区管理的，一切又显的整整有条。

对于数据和管理器，ZoneFire提供了一个注册器，只要用注册器把数据对象、管理器注册到ZoneFire框架，那么程序中的任何一个框架角色都能用一个内置的存取器（getter）在任何地方访问这些数据对象和管理器。此外，ZoneFire还提供了一个框架监视器（Monitor）来随时观察各框架角色、数据对象和管理器在框架中的活动情况（何时创建、何时签入、框架中有多少/哪些数据对象或管理器、有多少区域、各区域有多少/哪些侦听者等），这是debug最有力的武器。

下面，就让我们按不同的主题来全面了解ZoneFire框架的强大威力。此外，框架编写者还提供了两个工程实例，一个适用于FlashDevelop或FlashBuild，是个“全尺寸”的工程模板，全面演示了ZoneFire的各项功能；另一个适用于Flash IDE，演示了ZoneFire的核心功能。

主题：
综述
ZoneFire框架解决的问题
ZoneFire框架的理念
ZoneFire的框架角色
辅助类
接口IRole
关于角色Role和Zone、Bus
关于数据注册
ZoneFire框架的特点
框架角色的方法和属性
注册器Register的方法
监视器Monitor的方法
​问与答


一、综述：
ZoneFire框架：所谓ZoneFire框架其实质是一套架设于程序内的事件通信网络和数据访问系统。通信网络由框架角色Roles (Role, EchoRole, ViewRole)、事件总线Bus、事件区域Zone构成。数据访问系统由DataMap和ManagerMap及一个注册/管理数据用的Register构成。程序中的任何对象只要它是个框架角色（即继承自Role,EchoRole,ViewRole），都可以将事件定向派发到事件总线或目标区域（Zone），而签入到事件总线或目标区域的框架角色可轻易侦听到此事件（即框架角色之间可轻易构建点到点的通信）。同时任何框架角色可随时访问用Register注册过的数据/管理器对象。

二、zonefire框架的特点：
1、简单高效。整个框架不含注释时只有区区13KB代码（UTF-8码时为23KB），连辅助类在内只有11个类，用户需要直接接触的只有4个类：Role，EchoRole，ViewRole和Register；
容易学习。简则易随，用zonefire开发项目程序员大部分时间还是用AS3的原生语言，只有需要远程通讯或访问注册在框架中的数据/管理器的类才会继承Role，EchoRole，ViewRole。而三个框架角色和框架交互的方法都是一样的（一共只有11个共用方法和3个共用属性，代码中都有详细的中文注释）。新手只需要几个小时时间就可以掌握。
应用灵活。zonefire只解决编程时两个核心问题：对象间的远程通讯和全局数据/管理器的访问。对于具体的项目，程序员可以根据项目的规模、项目的功能、公司的技术理念、自己的编程习惯来构建项目的结构。比如你的项目要遵守MVC规则使视图层独立于数据层和控制层，那么你在项目中不要用ViewRole就是了。
无限可扩展性。zonefire并未针对任何具体的项目类型设定规则，而只是解决两个基本问题。所以你可以在zonefire基础上开发出各种适合自己工程特点的程序框架。zonefire只提供工具，项目开发规则由你自己制订。你可以直接用zonefire开发项目，也可以在zonefire上DIY自己的程序框架，用你自己制定的游戏规则来约束你手下的程序员。
适用广泛。zonefire不是傻瓜机那样包含了很多定制功能的框架，而是像单反相机一样给用户提供无限创作自由的框架。做一个几个小时就能完成的小项目，用zonefire你不会觉得累赘；做一个几十人合作开发的大项目，你不会觉得zonefire不够用，因为只要你的编程能力足够强，zonefire是可以无限扩展的。zonefire只解决两个核心问题，而没有太多条条框框的限制。
项目植入容易。即使是一个已经差不多完成的项目，要将zonefire植入也很容易，只要将某些需要远程通讯或访问全局数据的类所继承的EventDispatcher基类改成EchoRole，把Sprite基类改成ViewRole，然后即可开始修改代码享受到zonefire的各种框架功能带来的便利。你的工程植入zonefire后只是在继承了框架角色基类的类里增加了框架互动功能，和原来的代码不会产生任何冲突。退一万步讲即使你的类不方便继承Role/EcheRole/ViewRole也不要紧，只要在该类里创建一个Role的实例，它就可以该类的通信助手代替该类进行框架互动了。
容易Debug。zonefire的Monitor对象提供了对框架角色和已注册数据/管理器的极其精细的监控，任何时候都可以通过框架角色内置的monitor属性查看框架角色和已注册数据/管理器的活动情况、各种框架角色的统计数字、签入到各Zone和Bus的角色列表等。甚至角色侦听到框架事件后能知道是谁发送过来的，这是事件的可追索性大大提高。
简化代码，zonefire中区域事件是定向发送到目标区域的，只要是签入到目标区域的框架角色都能侦听到，也就是说框架事件是从发送者直达目标区域侦听者的（点到点直达），不像某些第三方框架一样需要通过其框架对象层层转发。这种机制不但简化了代码，还大大减轻大型项目中事件漫天飞的现象。
易于维护。角色是划区管理的，功能强大却又显得整整有条。事件区域的定义都是明码字符串，且框架事件是定向发送的，哪个角色注册到那个Zone，哪个角色发送什么事件到哪个Zone，代码中都一清二楚，这使得代码简单易懂，可读性强，易于维护。
所以点到点通信和事件定向发送是zonefire最大的特点。

三、zonefire框架解决的问题
做程序（任何一种语言），当项目规模大到一定程度（比如程序由多个模块构成，宿主程序有多个外挂的寄生程序）时，有两个问题会成为程序员的困扰：
各模块之间如何通信。程序是个整体，如何在一个模块中触发另外一个模块中的某些功能，如何把一个模块中的某些变化通知到其他模块而令其作出相应的反应？如何让主程序（宿主程序）和各运行时加载的swf子模块（寄生程序）以及寄生程序加载的swf孙模块之间进行无缝通信？
有点规模的程序总会有一些全局的数据（如来自xml的配置数据，后台服务数据）和管理器（如模块管理器、窗口管理器、服务管理器、缓存管理器、对象池、游戏任务管理器、战场管理器、错误管理器、日志管理器等）。这些数据和管理器你在任何地方都会可能调用，如何达到这个目的？现在比较常见的做法是通过一个类的静态属性或静态方法来实现对它们全局的访问。但这并不符合面向对象编程的理念，面向对象编程应该操作对象而不是类。

四、zonefire框架的理念
​在zonefire框架中，框架角色（Roles）是框架互动的主要参与者。程序中任何要进行框架互动（即上面所述的远程通讯和全局数据访问）的对象都可以通过继承Role/EchoRole/ViewRole三个基类中的一个成为框架角色。框架角色通过两种通信系统（事件总线Bus和事件区域Zone）来完成各角色之间的通信。
在zonefire框架中，将程序划分成一个个虚拟的事件区域(Zone)，程序员在创建框架角色时可以将角色签入到不同的Zone中。任何一个框架角色无需签入到任何Zone就可以把事件定向发送到指定的目标Zone（谓之“区域事件”，目标Zone可以是多个），而签入到目标Zone的框架角色就能侦听到该区域事件，但其他Zone中的框架角色却不受影响。这样做的好处是区域事件可以直达指定区域的某个/某些框架角色，而不需要其他中介的层层转发。而由于划区管理，又显得整整有条，且可随时扩展，使代码的可维护性和可扩展性大大提高。
zonefire还定义了一个事件总线Bus，Bus覆盖整个程序，即程序中任何框架角色都可以向Bus发送事件（谓之“总线事件”），而签入到Bus的任何框架角色都可以侦听到总线事件，即总线事件的射界是无限的。
zonefire中有个Register注册器，用此注册器可以将数据/管理器类注册到框架中，注册器即自动为该数据/管理器类创建唯一的实例，然后在任何一个框架角色中便可方便地通过内置的getData/getManager方法访问操控此数据/管理器实例。
由于框架角色是通过方法或get/set存取器访问事件中心、框架数据/管理器对象，所以因为使用ZoneFire而增加的开销微乎其微。
​框架事件使各对象之间脱偶，又能随时保持点到点通信，这使程序的可扩展性无限增加，模块切分更加容易。即使是宿主程序和寄生程序之间的通信/数据访问也畅通无阻，并且即使是多级的宿主-寄生程序之间也能实现点到点的通信。

五、zonefire的框架角色：
​框架角色是指具有框架事件交互能力，能随时访问注册到框架中的数据/管理器的类实例。程序员使用zonefire主要接触的即是框架角色类，它们像EventDispatcher、Sprite一样是构建程序的基石。
zonefire框架有三个框架角色类：Role,EchoRole,ViewRole。Role最纯净，没有继承任何基类；EchoRole继承自EventDispatcher，不但可以发送/侦听框架事件，自身也可以发送/侦听非框架事件；而ViewRole继承自Sprite，所以其实例可以直接添加到显示列表。
三个框架角色拥有相同的框架功能（AS3不支持多重继承所以只能这样做，否则只需一个Role就可以了。EchoRole等同于同时继承了Role和EventDispatcher，ViewRole等同于同时继承了Role和Sprite。）。
一般来说用Role和ViewRole即可。Role做无视图的角色，ViewRole做可视化的角色。由于Role和ViewRole都可以发送/侦听框架事件，已经能满足日常开发。EchoRole比Role多了个自己能发送和侦听非框架事件的功能。EchoRole的地位比较尴尬，事实上我犹豫了好久才决定保留它，这主要是考虑到如果有工程已经做了一半甚至基本完成，而此时要把zonefire框架植入到此工程中，用EchoRole代替原来的EventDispatcher作为基类就不用改原来的代码。事实上，无论是EchoRole还是ViewRole，其起框架互动功能的还是其里面的Role。
   
六、辅助类
​Register类：程序中往往有一些数据或管理器，可能在程序的任何地方调用。Register类的作用就是把这些数据/管理器注册到zonefire框架，这样在任何的框架角色内都可以轻松调用。当然，已经注册的数据/管理器也可以用Register删除。Register里的方法都是静态的，所以在程序的任何地方（即使非框架角色）中都可以调用其方法注册/删除数据或管理器。
Monitor类：Monitor类是用来监视框架角色及所注册的数据/管理器对象的活动情况的。对于程序本身来说它并没有任何用途，但是开发时它是有力的Debug工具（比如查看某个数据/管理器对象是否存在；Bus或某个Zone签入了多少个角色，其名字是什么；某个角色是否在Bus或某Zone中签入过）。Monitor只有一个唯一的实例，框架角色内置了访问该实例的get方法。

七、接口IRole
三个框架角色Role、EchoRole和ViewRole都实现了IRole接口，也就是说三个框架角色有相同的框架功能，其他功能的差别即是其基类功能的差别。

八、关于角色和Zone、Bus
​一个程序可以有任意多个事件区域Zone。Zone是虚拟区域，和程序具体的功能、模块划分无关。比如在游戏的商店模块中，你可以把模块中的限时促销角色注册到A Zone，把普通交易角色注册到B Zone，而同时把数据模块的一个角色注册到A Zone。这并不会让zonefire的框架通信产生互相干扰。但是按功能模块或按功能区域来划分Zone是个好习惯，这样会使你的程序更容易理解也更容易维护。
Zone用名称（字符串）来区别于其他的Zone。当角色执行signInZone (zoneName:String)方法时zonefire会在框架中搜索，如果没有找到该名称的Zone会自动创建新Zone，如果找到了即将该角色注册到该Zone。
角色只能侦听到其所属的当前Zone的框架事件，所以侦听区域事件之前需先签入某个Zone。而发送区域事件则不需要签入到任何Zone（一个角色可以同时向多个目标Zone发送区域事件）。
角色在整个生命周期中只能签入到Bus和Zone一次，重复签入不会执行，改签到其他Zone会抛出错误。
角色执行dispose()方法后会自动从Bus或/和所属Zone中签出。不能手动签出，但可以删除对Bus或Zone的侦听。
一个程序（无论其切分成多少个swf）只有一个唯一的Bus（系统自动创建）。Bus跨越所有Zone，覆盖整个程序所有角色，所以总线事件的射界是无限的，即任何角色（无论是否签入到Bus）都可以发送总线事件，任何角色（无论其签入到那个Zone甚至没有签入到任何Zone）只要签入到Bus都可以侦听到全部的总线事件。这种能力是恐怖的，但过多使用总线事件显然也会使程序逻辑变得混乱。事实上我曾一度取消总线事件的功能，之所以后来恢复是考虑到一些小项目没有必要用相对较复杂的Zone。事实上程序只定义一个Zone即可获得和Bus相同的通信广度，所以Bus是为菜鸟准备的。
请记住一句话：Bus是为菜鸟准备的，稍微有点自尊心的程序员都不应该使用它。

九、关于数据注册
​任何时候在任何地方都可以用Register将数据/管理器注册到框架，或把已经注册的数据/管理器对象实例删除；用户对数据的管理都通过Register进行，不直接接触框架内部的数据保存、管理类；
框架数据都是唯一的，即每个数据类/管理器类只有一个唯一的实例。尝试将一个类重复注册到框架会抛出错误。如果同一个类有多个实例，则应该在一个将/已注册的数据/管理器对象内创建这些实例，将其作为二级数据来进行管理。比如说你有5个商店的数据使用了相同的类，那么不应该将这5个商店的数据直接注册为框架的一级数据，而应该先创建一个StoreData类并注册到框架，然后在StoreData类里面创建这5个商店的数据对象。
​​一旦数据注册成功，在任何一个Role、EchoRole或ViewRole实例中立即就可以通过其类名对数据对象进行访问。


----------------------------------------------------------------------------------------------------------------


十、框架角色的方法和属性：

角色方法：
1、signInBus ():Boolean
将角色签入到事件总线Bus。角色签入到Bus才能侦听总线事件，但发送事件到Bus则无需先签入。
该实例在整个生命周期中只能签入一次，重复签入将被忽略。

2、fireBus (evt:Event):void
发送事件到事件总线Bus。

3、addBusListener (type:String, listener:Function, useCapture:Boolean=false, priority:int=0, useWeakReference:Boolean=false):void
侦听发送到事件总线Bus的事件。角色须签入到总线才能侦听总线事件。

4、removeBusListener (type:String, listener:Function, useCapture:Boolean=false):void
删除事件总线Bus上的事件侦听，如果该侦听不存在则自动忽略。

5、signInZone (zoneName:String):Boolean
签入到指定名称的Zone(若无此Zone会自动创建)，签入后该实例成为此Zone的一个角色，可以侦听其他角色发送到该角色所处Zone的事件。
若不签入则该实例不属于任何Zone，可以发送事件到指定Zone但无法侦听任何Zone的事件。
一个实例在整个生命周期中只能签入一次。重复签入不会被执行(返回false)。改签到其他Zone会抛出错误。

6、fireZone (evt:Event, zoneName:String):void
发送事件到指定Zone。发送事件前框架会检测目标Zone是否存在，若目标Zone不存在则自动终止事件的发送。

7、addZoneListener (type:String, listener:Function, useCapture:Boolean=false, priority:int=0, useWeakReference:Boolean=false):void
侦听其他角色发送到该角色所处Zone的事件

8、removeZoneListener (type:String, listener:Function, useCapture:Boolean=false):void
删除对该角色所处Zone的事件侦听，如果该侦听不存在则自动忽略。

9、getData(dataClass:Class):*
获取DataHall中指定类型的数据对象，该数据对象必须事先用Register类注册到zonefire框架的DataHall。

10、getManager(managerClass:Class):*
获取ManagerHall中指定类型的管理器，该管理器必须事先用Register类注册到zonefire框架的ManagerHall

11、dispose ():void
销毁实例,如果实例已经签入Bos/Zone则会自动从Bus和Zone中签出。

角色属性：
1、monitor
事件总线和事件区域监视器。通过该监视器可查看角色在事件总线/事件区域中的活动情况，及事件总线/事件区域的各项统计数字。监视器不干涉框架中的任何活动而只是监视其活动，用于

2、roleName
角色在ZoneFire框架中的名称，只读，在签入到Bus/Zone时由系统自动创建，由类名字符串+角色序号(角色签入Bus/Zone的先后次序)构成，仅起标识和统计作用。
未签入到Bus/Zone的角色其roleName为null

3、zoneName
角色所属事件区域的名称，只读。


十一、注册器Register的方法：
1、regData (dataClass:Class) : *
·把数据类型注册到大厅。注册成功后系统自动创建并返回该类的唯一实例；
·注册后在所有的Role/EchoRole/ViewRole中均可以通过getData(dataClass:Class)方法访问该数据对象；
·用相同类型注册会被视为重复注册，注册不会被执行并抛出错误，以此保证数据的唯一性。但可以先删除原有的数据再用相同的名称注册；
·如果有相同类型的多个数据，应该将其作为二级数据存放在注册到数据大厅的类中，而不应该作为一级数据直接注册到数据大厅；

2、regDataInstance (dataInstance:any, dataClass:Class) : *
·把数据实例注册到数据大厅。注册成功后返回此数据实例。此方法适用于一些因构造函数有参数而无法用regData方法注册的数据类。
·注册后在所有的Role/EchoRole/ViewRole中均可以通过getData(dataClass:Class)方法访问该数据对象。
·用相同类型注册会被视为重复注册，注册不会被执行并抛出错误，以此保证数据的唯一性。但可以先删除原有的数据再用相同的名称注册。
·如果有相同类型的多个数据，应该将其作为二级数据存放在注册到数据大厅的类实例中，而不应该作为一级数据直接注册到数据大厅；

3、deleteData (dataClass:Class) : Boolean
从数据大厅中删除指定类型的数据对象(无论此对象是用regData()方法还是regDataInstance()方法注册)。

4、regManager (managerClass:any) : *
·将管理器类型注册到管理大厅。注册成功后系统自动创建并返回该类的唯一实例。
·注册后在所有的Role/EchoRole/ViewRole中均可以通过getManager(managerClass:Class)方法访问该管理器对象。
·用相同类型注册会被视为重复注册，注册不会被执行并抛出错误，以此保证数据的唯一性。但可以先删除原有的管理器再用相同的类型注册。

5、regManagerInstance (managerInstance:any, managerClass:Class) : *
·将管理器实例注册到管理器大厅。注册成功后返回此管理器实例。此方法适用于一些因构造函数有参数而无法用regManager方法注册的管理器类。
·注册后在所有的Role/EchoRole/ViewRole中均可以通过getManager(managerClass:Class)方法访问该管理器。
·用相同类型注册会被视为重复注册，注册不会被执行并抛出错误，以此保证数据的唯一性。但可以先删除原有的管理器再用相同的类型注册。

6、deleteManager (managerClass:Class) : Boolean
从管理器大厅中删除指定类型的管理器(无论此管理器是用regManager()方法还是regManagerInstance()方法注册)。


十二、监视器Monitor的方法：
1、inBus (roleName:String) : Boolean
指定名称的角色是否已经签入到事件总线。

2、rolesInBus () : Array
已经签入到Bus的所有角色名列表(在Bus中所有签入者都是事件侦听者)。

3、zoneNum () : int
获取程序中zone的总数。

4、zoneList () : Array
程序中所有zone的名称列表。

5、hasZone (zoneName:String) : Boolean
检测指定名称的zone是否存在。

6、inZone (zoneName:String, roleName:String) : Boolean
在指定名称的Zone中检测是否存在指定名称的角色。

7、rolesInZone (zoneName:String) : Array
列出指定Zone里的所有角色名。

8、dataNum () : int
数据大厅中数据对象的数量。

9、hasData (dataClass:Class) : Boolean
数据大厅中是否存在指定类型的数据对象。

10、dataList () : Array
列出在数据大厅里注册过的所有数据对象的类名列表

11、managerNum () : int
管理大厅中管理器的数量。

12、hasManager (managerClass:Class) : Boolean
管理器大厅中是否存在指定类型的管理器。

13、managerList () : Array
列出在管理器大厅里注册过的所有管理器的类名列表。

十三：问与答
1、为什么Zone名称，角色名称用字符串
字符串是AS3所有类型中最接近自然语言的类型，它具有具体的意义。用字符串来标识Zone和角色，尽管不如用整数标识那么容易管理，但能使代码更容易阅读。
2、角色可以同时签入Bus和Zone或两方都不签入吗？
可以。事件总线Bus和事件区域Zone是互相独立的，一个角色可以单签入任何一方，也可以同时签入两方，也可以两方都不签入。签入不签入在功能上的区别是签入到某方就能侦听该处的框架事件，而不签入的角色只能发送框架事件和访问注册到框架中的数据/管理器。
3、Monitor集成了那么多的统计功能，会很消耗资源吧？
Monitor作为统计器，其本身并不保存数据，而只是提供一些统计数据的方法。所以，只要你不去执行就不会消耗额外的资源。推荐的方法时将和Monitor有关的代码写在CONFIG::debug标签内以保证其只在debug模式下执行:
if(CONFIG::debug){
	trace(monitor.rolesInZone("ZONE_A"))
}






